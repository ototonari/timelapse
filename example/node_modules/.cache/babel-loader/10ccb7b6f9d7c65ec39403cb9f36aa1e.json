{"ast":null,"code":"var _jsxFileName = \"/Volumes/ST-side-SSD/tsubasa/engineer/playground/typescript/timelapse-app/node_modules/timelapse/src/component/Timelapse.tsx\";\nimport React, { Component } from 'react';\nimport { ee } from \"timelapse/src/lib/Events\";\nvar LoadStatus;\n\n(function (LoadStatus) {\n  LoadStatus[LoadStatus[\"Loading\"] = 0] = \"Loading\";\n  LoadStatus[LoadStatus[\"Loaded\"] = 1] = \"Loaded\";\n})(LoadStatus || (LoadStatus = {}));\n\nvar EventEmittStatus;\n\n(function (EventEmittStatus) {\n  EventEmittStatus[\"ALLREADYLOAD\"] = \"ALL_READY_LOAD\";\n  EventEmittStatus[\"START\"] = \"TIMELAPSE_START\";\n  EventEmittStatus[\"STOP\"] = \"TIMELAPSE_STOP\";\n})(EventEmittStatus || (EventEmittStatus = {}));\n\nclass Timelapse extends Component {\n  constructor(props) {\n    super(props);\n    this.images = null;\n    this.canvas = React.createRef();\n    this.intervalId = null;\n    this.fpsForMilisecond = void 0;\n\n    this.imagePreLoader = (srcs, cb) => {\n      const images = srcs.map((src, index) => {\n        const img = new Image(); // 画像のプリロードを始める\n\n        img.src = src;\n        img.onload = cb(index);\n        return img;\n      });\n      return images;\n    };\n\n    this.enableTimelapse = () => {\n      this.intervalId = setInterval(() => {\n        const renderingIndex = this.state.renderingIndex;\n        this.drawCanvas(renderingIndex);\n        this.setState(prevState => ({\n          renderingIndex: prevState.renderingIndex < prevState.loadStatusList.length - 1 ? prevState.renderingIndex + 1 : 0\n        }));\n      }, this.fpsForMilisecond);\n    };\n\n    this.disableTimelapse = () => {\n      if (this.intervalId) clearInterval(this.intervalId);\n    };\n\n    this.drawCanvas = index => {\n      if (this.images === null) return; // this.images から描画する image object を取り出す\n\n      const img = this.images[index];\n      if (img === null) return;\n      const canvas = this.canvas.current;\n      if (canvas === null) return;\n      const ctx = canvas.getContext(\"2d\");\n      if (ctx === null) return;\n      const _this$props = this.props,\n            width = _this$props.width,\n            height = _this$props.height; // canvas に描画する\n\n      ctx.drawImage(img, 0, 0, width, height);\n    };\n\n    this.state = {\n      // 画像の読み込み状態を格納した配列\n      loadStatusList: this.props.images.map(() => LoadStatus.Loading),\n      // 描画する画像のインデックス\n      renderingIndex: 0 // イメージのローディングが終わったら発火する\n\n    };\n    ee.once(EventEmittStatus.ALLREADYLOAD, this.props.preloadedCallback); // タイムラプス始まる\n\n    ee.on(EventEmittStatus.START, this.enableTimelapse); // タイムラプス終わる\n\n    ee.on(EventEmittStatus.STOP, this.disableTimelapse); // fps を ミリセカンドに変換する\n\n    this.fpsForMilisecond = 3500 / this.props.fps;\n  }\n\n  componentDidMount() {\n    // 画像のプリロードを始める\n    const images = this.props.images;\n    const srcs = images.map(image => image.src);\n    this.images = this.imagePreLoader(srcs, i => {\n      // 読み込みが終われば、ステートの読み込み状態を変更する\n      this.setState(prevState => {\n        const newLoadStatusList = prevState.loadStatusList.concat();\n        newLoadStatusList[i] = LoadStatus.Loaded; // イメージのローディングが終わったことを知らせるイベント\n\n        const allReadyLoad = newLoadStatusList.every(loadStatus => loadStatus === LoadStatus.Loaded);\n\n        if (allReadyLoad) {\n          ee.emit(EventEmittStatus.ALLREADYLOAD, this.props.preloadedCallback);\n        }\n\n        return {\n          loadStatusList: newLoadStatusList\n        };\n      });\n    });\n  }\n\n  componentDidUpdate(prevProps) {\n    // プロパティから再生、停止を受け取り、処理する\n    const timelapseHandle = this.props.timelapseHandle;\n    if (timelapseHandle === prevProps.timelapseHandle) return;\n\n    switch (timelapseHandle) {\n      case true:\n        ee.emit(EventEmittStatus.START);\n        console.log(\"start timelapse\");\n        break;\n\n      case false:\n        ee.emit(EventEmittStatus.STOP);\n        console.log(\"stop timelapse\");\n        break;\n\n      default:\n        break;\n    }\n  } // 画像のプリロードを担当する\n\n\n  render() {\n    const _this$props2 = this.props,\n          width = _this$props2.width,\n          height = _this$props2.height;\n    return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 147\n      },\n      __self: this\n    }, React.createElement(\"canvas\", {\n      ref: this.canvas,\n      width: width,\n      height: height,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 148\n      },\n      __self: this\n    })));\n  }\n\n}\n\nexport default Timelapse;","map":{"version":3,"sources":["/Volumes/ST-side-SSD/tsubasa/engineer/playground/typescript/timelapse-app/node_modules/timelapse/src/component/Timelapse.tsx"],"names":["React","Component","ee","LoadStatus","EventEmittStatus","Timelapse","constructor","props","images","canvas","createRef","intervalId","fpsForMilisecond","imagePreLoader","srcs","cb","map","src","index","img","Image","onload","enableTimelapse","setInterval","renderingIndex","state","drawCanvas","setState","prevState","loadStatusList","length","disableTimelapse","clearInterval","current","ctx","getContext","width","height","drawImage","Loading","once","ALLREADYLOAD","preloadedCallback","on","START","STOP","fps","componentDidMount","image","i","newLoadStatusList","concat","Loaded","allReadyLoad","every","loadStatus","emit","componentDidUpdate","prevProps","timelapseHandle","console","log","render"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAA4C,OAA5C;AACA,SAASC,EAAT,QAAmB,0BAAnB;IAqBKC,U;;WAAAA,U;AAAAA,EAAAA,U,CAAAA,U;AAAAA,EAAAA,U,CAAAA,U;GAAAA,U,KAAAA,U;;IAKAC,gB;;WAAAA,gB;AAAAA,EAAAA,gB;AAAAA,EAAAA,gB;AAAAA,EAAAA,gB;GAAAA,gB,KAAAA,gB;;AAML,MAAMC,SAAN,SAAwBJ,SAAxB,CAAmE;AAKjEK,EAAAA,WAAW,CAACC,KAAD,EAAwB;AACjC,UAAMA,KAAN;AADiC,SAJnCC,MAImC,GAJC,IAID;AAAA,SAHnCC,MAGmC,GAHIT,KAAK,CAACU,SAAN,EAGJ;AAAA,SAFnCC,UAEmC,GAFC,IAED;AAAA,SADnCC,gBACmC;;AAAA,SA4DnCC,cA5DmC,GA4DlB,CAACC,IAAD,EAAiBC,EAAjB,KAA6B;AAC5C,YAAMP,MAAM,GAAGM,IAAI,CAACE,GAAL,CAAS,CAACC,GAAD,EAAMC,KAAN,KAAgB;AACtC,cAAMC,GAAG,GAAG,IAAIC,KAAJ,EAAZ,CADsC,CAEtC;;AACAD,QAAAA,GAAG,CAACF,GAAJ,GAAUA,GAAV;AACAE,QAAAA,GAAG,CAACE,MAAJ,GAAaN,EAAE,CAACG,KAAD,CAAf;AACA,eAAOC,GAAP;AACD,OANc,CAAf;AAOA,aAAOX,MAAP;AACD,KArEkC;;AAAA,SAwEnCc,eAxEmC,GAwEjB,MAAM;AACtB,WAAKX,UAAL,GAAkBY,WAAW,CAAC,MAAM;AAAA,cAC1BC,cAD0B,GACP,KAAKC,KADE,CAC1BD,cAD0B;AAElC,aAAKE,UAAL,CAAgBF,cAAhB;AAEA,aAAKG,QAAL,CAAcC,SAAS,KAAK;AAC1BJ,UAAAA,cAAc,EAAGI,SAAS,CAACJ,cAAV,GAA2BI,SAAS,CAACC,cAAV,CAAyBC,MAAzB,GAAkC,CAA9D,GAAmEF,SAAS,CAACJ,cAAV,GAA2B,CAA9F,GAAkG;AADxF,SAAL,CAAvB;AAGD,OAP4B,EAO1B,KAAKZ,gBAPqB,CAA7B;AAQD,KAjFkC;;AAAA,SAoFnCmB,gBApFmC,GAoFhB,MAAM;AACvB,UAAI,KAAKpB,UAAT,EAAqBqB,aAAa,CAAC,KAAKrB,UAAN,CAAb;AACtB,KAtFkC;;AAAA,SAyFnCe,UAzFmC,GAyFrBR,KAAD,IAAmB;AAC9B,UAAI,KAAKV,MAAL,KAAgB,IAApB,EAA0B,OADI,CAE9B;;AACA,YAAMW,GAAG,GAAG,KAAKX,MAAL,CAAYU,KAAZ,CAAZ;AACA,UAAIC,GAAG,KAAK,IAAZ,EAAkB;AAClB,YAAMV,MAAM,GAAG,KAAKA,MAAL,CAAYwB,OAA3B;AACA,UAAIxB,MAAM,KAAK,IAAf,EAAqB;AACrB,YAAMyB,GAAG,GAAGzB,MAAM,CAAC0B,UAAP,CAAkB,IAAlB,CAAZ;AACA,UAAID,GAAG,KAAK,IAAZ,EAAkB;AARY,0BASJ,KAAK3B,KATD;AAAA,YAStB6B,KATsB,eAStBA,KATsB;AAAA,YASfC,MATe,eASfA,MATe,EAU9B;;AACAH,MAAAA,GAAG,CAACI,SAAJ,CAAcnB,GAAd,EAAmB,CAAnB,EAAsB,CAAtB,EAAyBiB,KAAzB,EAAgCC,MAAhC;AACD,KArGkC;;AAEjC,SAAKZ,KAAL,GAAa;AACX;AACAI,MAAAA,cAAc,EAAE,KAAKtB,KAAL,CAAWC,MAAX,CAAkBQ,GAAlB,CAAsB,MAAMb,UAAU,CAACoC,OAAvC,CAFL;AAGX;AACAf,MAAAA,cAAc,EAAE,CAJL,CAMb;;AANa,KAAb;AAOAtB,IAAAA,EAAE,CAACsC,IAAH,CAAQpC,gBAAgB,CAACqC,YAAzB,EAAuC,KAAKlC,KAAL,CAAWmC,iBAAlD,EATiC,CAUjC;;AACAxC,IAAAA,EAAE,CAACyC,EAAH,CAAMvC,gBAAgB,CAACwC,KAAvB,EAA8B,KAAKtB,eAAnC,EAXiC,CAYjC;;AACApB,IAAAA,EAAE,CAACyC,EAAH,CAAMvC,gBAAgB,CAACyC,IAAvB,EAA6B,KAAKd,gBAAlC,EAbiC,CAcjC;;AACA,SAAKnB,gBAAL,GAAwB,OAAO,KAAKL,KAAL,CAAWuC,GAA1C;AACD;;AAEDC,EAAAA,iBAAiB,GAAG;AAClB;AADkB,UAEVvC,MAFU,GAEC,KAAKD,KAFN,CAEVC,MAFU;AAGlB,UAAMM,IAAI,GAAGN,MAAM,CAACQ,GAAP,CAAYgC,KAAD,IAAgBA,KAAK,CAAC/B,GAAjC,CAAb;AACA,SAAKT,MAAL,GAAc,KAAKK,cAAL,CAAoBC,IAApB,EAA2BmC,CAAD,IAAe;AACrD;AACA,WAAKtB,QAAL,CAAcC,SAAS,IAAI;AACzB,cAAMsB,iBAAiB,GAAGtB,SAAS,CAACC,cAAV,CAAyBsB,MAAzB,EAA1B;AACAD,QAAAA,iBAAiB,CAACD,CAAD,CAAjB,GAAuB9C,UAAU,CAACiD,MAAlC,CAFyB,CAIzB;;AACA,cAAMC,YAAY,GAAGH,iBAAiB,CAACI,KAAlB,CAAyBC,UAAD,IAAiBA,UAAU,KAAKpD,UAAU,CAACiD,MAAnE,CAArB;;AACA,YAAIC,YAAJ,EAAkB;AAChBnD,UAAAA,EAAE,CAACsD,IAAH,CAAQpD,gBAAgB,CAACqC,YAAzB,EAAuC,KAAKlC,KAAL,CAAWmC,iBAAlD;AACD;;AAED,eAAO;AACLb,UAAAA,cAAc,EAAEqB;AADX,SAAP;AAGD,OAbD;AAcD,KAhBa,CAAd;AAiBD;;AAEDO,EAAAA,kBAAkB,CAACC,SAAD,EAA4B;AAC5C;AAD4C,UAEpCC,eAFoC,GAEhB,KAAKpD,KAFW,CAEpCoD,eAFoC;AAG5C,QAAIA,eAAe,KAAKD,SAAS,CAACC,eAAlC,EAAmD;;AACnD,YAAQA,eAAR;AACE,WAAK,IAAL;AACEzD,QAAAA,EAAE,CAACsD,IAAH,CAAQpD,gBAAgB,CAACwC,KAAzB;AACAgB,QAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACA;;AACF,WAAK,KAAL;AACE3D,QAAAA,EAAE,CAACsD,IAAH,CAAQpD,gBAAgB,CAACyC,IAAzB;AACAe,QAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACA;;AACF;AACE;AAVJ;AAYD,GA9DgE,CAgEjE;;;AA4CAC,EAAAA,MAAM,GAAG;AAAA,yBACoB,KAAKvD,KADzB;AAAA,UACE6B,KADF,gBACEA,KADF;AAAA,UACSC,MADT,gBACSA,MADT;AAGP,WACE,0CACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AAAQ,MAAA,GAAG,EAAE,KAAK5B,MAAlB;AAA0B,MAAA,KAAK,EAAE2B,KAAjC;AAAwC,MAAA,MAAM,EAAEC,MAAhD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,CADF,CADF;AAOD;;AAtHgE;;AAwHnE,eAAehC,SAAf","sourcesContent":["import React, { Component, RefObject } from 'react';\nimport { ee } from \"timelapse/src/lib/Events\";\n\nexport interface ImageProps {\n  src: string,\n  alt: string\n}\n\ninterface TimelapseProps {\n  width: number,\n  height: number,\n  images: ImageProps[],\n  preloadedCallback: () => void,\n  timelapseHandle: boolean | null,\n  fps: number\n}\n\ninterface TimelapseStatus {\n  loadStatusList: LoadStatus[],\n  renderingIndex: number\n}\n\nenum LoadStatus {\n  Loading = 0,\n  Loaded = 1\n}\n\nenum EventEmittStatus {\n  ALLREADYLOAD = \"ALL_READY_LOAD\",\n  START = \"TIMELAPSE_START\",\n  STOP = \"TIMELAPSE_STOP\"\n}\n\nclass Timelapse extends Component<TimelapseProps, TimelapseStatus> {\n  images: HTMLImageElement[] | null = null\n  canvas: RefObject<HTMLCanvasElement> = React.createRef()\n  intervalId: NodeJS.Timeout | null = null\n  fpsForMilisecond: number;\n  constructor(props: TimelapseProps) {\n    super(props)\n    this.state = {\n      // 画像の読み込み状態を格納した配列\n      loadStatusList: this.props.images.map(() => LoadStatus.Loading),\n      // 描画する画像のインデックス\n      renderingIndex: 0\n    }\n    // イメージのローディングが終わったら発火する\n    ee.once(EventEmittStatus.ALLREADYLOAD, this.props.preloadedCallback)\n    // タイムラプス始まる\n    ee.on(EventEmittStatus.START, this.enableTimelapse)\n    // タイムラプス終わる\n    ee.on(EventEmittStatus.STOP, this.disableTimelapse)\n    // fps を ミリセカンドに変換する\n    this.fpsForMilisecond = 3500 / this.props.fps\n  }\n\n  componentDidMount() {\n    // 画像のプリロードを始める\n    const { images } = this.props\n    const srcs = images.map((image: any) => image.src)\n    this.images = this.imagePreLoader(srcs, (i: number) => {\n      // 読み込みが終われば、ステートの読み込み状態を変更する\n      this.setState(prevState => {\n        const newLoadStatusList = prevState.loadStatusList.concat()\n        newLoadStatusList[i] = LoadStatus.Loaded\n\n        // イメージのローディングが終わったことを知らせるイベント\n        const allReadyLoad = newLoadStatusList.every((loadStatus) => (loadStatus === LoadStatus.Loaded))\n        if (allReadyLoad) {\n          ee.emit(EventEmittStatus.ALLREADYLOAD, this.props.preloadedCallback)\n        }\n\n        return {\n          loadStatusList: newLoadStatusList\n        }\n      })\n    })\n  }\n\n  componentDidUpdate(prevProps: TimelapseProps) {\n    // プロパティから再生、停止を受け取り、処理する\n    const { timelapseHandle } = this.props\n    if (timelapseHandle === prevProps.timelapseHandle) return\n    switch (timelapseHandle) {\n      case true:\n        ee.emit(EventEmittStatus.START)\n        console.log(\"start timelapse\")\n        break\n      case false:\n        ee.emit(EventEmittStatus.STOP)\n        console.log(\"stop timelapse\")\n        break\n      default:\n        break\n    }\n  }\n\n  // 画像のプリロードを担当する\n  imagePreLoader = (srcs: string[], cb: any) => {\n    const images = srcs.map((src, index) => {\n      const img = new Image()\n      // 画像のプリロードを始める\n      img.src = src\n      img.onload = cb(index)\n      return img\n    })\n    return images\n  }\n  \n  // タイムラプスを始める\n  enableTimelapse = () => {\n    this.intervalId = setInterval(() => {\n      const { renderingIndex } = this.state\n      this.drawCanvas(renderingIndex)\n  \n      this.setState(prevState => ({\n        renderingIndex: (prevState.renderingIndex < prevState.loadStatusList.length - 1) ? prevState.renderingIndex + 1 : 0\n      }))\n    }, this.fpsForMilisecond)\n  }\n\n  // タイムラプスを停止する\n  disableTimelapse = () => {\n    if (this.intervalId) clearInterval(this.intervalId)\n  }\n\n  // canvas に描画する\n  drawCanvas = (index: number) => {\n    if (this.images === null) return\n    // this.images から描画する image object を取り出す\n    const img = this.images[index]\n    if (img === null) return \n    const canvas = this.canvas.current\n    if (canvas === null) return \n    const ctx = canvas.getContext(\"2d\")\n    if (ctx === null) return\n    const { width, height } = this.props\n    // canvas に描画する\n    ctx.drawImage(img, 0, 0, width, height)\n  }\n\n  render() {\n    const {  width, height } = this.props\n\n    return(\n      <>\n        <div>\n          <canvas ref={this.canvas} width={width} height={height} />\n        </div>\n      </>\n    )\n  }\n}\nexport default Timelapse"]},"metadata":{},"sourceType":"module"}